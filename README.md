# CleanCode
A Summary of Clean Code Book
## Index
```
	Index:
	├── Chapter 1: Clean Code
	├── Chapter 2:  Meaningfull name
	├── Chapter 3: Functions
	├── Chapter 4: Comments
	├── Chapter 5: Formating
	├── Chapter 6: Objects And Data Structures
	├── Chapter 7: Error Handling
	├── Chapter 8: Boundries
	├── Chapter 9: Unit tests
	├── Chapter 10: Classes
	├── Chapter 11: System
	├── Chapter 12: Emergence 
	├── Chapter 13:Concurrency
	├── Chapter 14: Successive Refinement
	├── Chapter 15: JUnit Internals
	├── Chapter 16:Refactoring serial Data
	└── Chapter 17:Smells And Huristics
```

## Chapter 1: Clean Code
### There will be code:
Sometime we think that in future we might not need any coder , bcz we will create a programm that will generate all codes.  That wont happen bcz code is expressing language of our requirments. By time our Requirments and specifications will be changed , for fullfilling that changes we will always need specific codes.

### Bad Code
We try to develop our product with rush and just working code. we keep cleanning up the codes for later. But day by day the working bad codes create lots of bugs in future. It could breakdown a company for handling those unclean codes.  We all know the law later equal never. 
### The Total Cost of Owning a Mess
If you continue the development with unclean code, later modification and adding of that code will be hard. The scaleability will be almost zero. So the aggregated bunch of unclean code could cost you whole fortune.
### The Grand Redesign in the Sky
When you will realise that the we cannt make any changes on that messy code , you have to redesign the same functionality code with deiffernt experts. And if that experts dont code cleanely then you have to redesign it again and again. 
###
## Chapter 2:  Meaningfull name
###
## Chapter 3: Functions
## Chapter 4: Comments
## Chapter 5: Formating
## Chapter 6: Objects And Data Structures
## Chapter 7: Error Handling
## Chapter 8: Boundries
## Chapter 9: Unit tests
## Chapter 10: Classes
## Chapter 11: System
## Chapter 12: Emergence 
## Chapter 13:Concurrency
## Chapter 14: Successive Refinement
## Chapter 15: JUnit Internals
## Chapter 16:Refactoring serial Data
## Chapter 17:Smells And Huristics
